<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Algorithms: Logic and Code (Python)</title>
    <style>
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            line-height: 1.8;
            color: #333;
            margin: 0;
            padding: 20px;
            background-color: #f0f2f5;
        }
        .container {
            max-width: 1200px;
            margin: auto;
            background: #ffffff;
            padding: 40px;
            border-radius: 12px;
            box-shadow: 0 4px 20px rgba(0,0,0,0.08);
        }
        h1 {
            text-align: center;
            color: #2c3e50;
            margin-bottom: 40px;
            font-size: 3.2em;
            letter-spacing: 1px;
            border-bottom: 4px solid #3498db;
            padding-bottom: 20px;
        }
        h2 {
            color: #34495e;
            margin-top: 0;
            font-size: 2.4em;
            flex-grow: 1;
        }
        h3 {
            color: #2980b9;
            margin-top: 35px;
            font-size: 1.9em;
        }
        h4 {
            color: #1e6d9b;
            margin-top: 25px;
            font-size: 1.5em;
        }
        p {
            margin-bottom: 15px;
            text-align: justify;
        }
        ul {
            list-style-type: disc;
            margin-left: 35px;
            margin-bottom: 15px;
        }
        ol {
            list-style-type: decimal;
            margin-left: 35px;
            margin-bottom: 15px;
        }
        code {
            font-family: 'Fira Code', 'Cascadia Code', 'Consolas', monospace;
            background-color: #e0e6ed;
            padding: 2px 5px;
            border-radius: 4px;
            color: #c0392b;
        }
        pre {
            background-color: #2d2d2d;
            color: #f8f8f2;
            padding: 20px;
            border-radius: 8px;
            overflow-x: auto;
            font-family: 'Fira Code', 'Cascadia Code', 'Consolas', monospace;
            font-size: 0.9em;
            line-height: 1.5;
            box-shadow: inset 0 0 8px rgba(0,0,0,0.3);
            margin-top: 20px;
            margin-bottom: 20px;
        }
        strong {
            color: #e74c3c;
        }
        .concept-section {
            background-color: #f8fafa;
            border: 1px solid #e0e6ed;
            border-radius: 8px;
            padding: 30px 35px;
            margin-bottom: 40px;
            box-shadow: 0 2px 12px rgba(0,0,0,0.06);
        }
        .concept-section h2 {
            margin-top: 0;
            color: #2c3e50;
        }
        .code-block {
            margin-top: 15px;
            margin-bottom: 15px;
        }
        .note {
            background-color: #fff3cd;
            border-left: 6px solid #ffc107;
            padding: 15px 25px;
            margin-top: 30px;
            border-radius: 8px;
            color: #6a4f00;
        }
        .warning {
            background-color: #f8d7da;
            border-left: 6px solid #dc3545;
            padding: 15px 25px;
            margin-top: 30px;
            border-radius: 8px;
            color: #721c24;
        }

        /* --- Collapsible Specific Styles --- */
        .collapsible-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            cursor: pointer;
            padding-bottom: 12px;
            border-bottom: 2px solid #ecf0f1;
            margin-bottom: 20px;
        }
        .toggle-button {
            background-color: #3498db;
            color: white;
            border: none;
            padding: 10px 15px;
            border-radius: 5px;
            cursor: pointer;
            font-size: 1em;
            transition: background-color 0.3s ease;
            min-width: 90px;
            text-align: center;
        }
        .toggle-button:hover {
            background-color: #2980b9;
        }
        .toggle-button.collapsed {
            background-color: #95a5a6;
        }
        .collapsible-content {
            display: none;
            padding-top: 10px;
        }
        .collapsible-content.expanded {
            display: block;
        }
        table {
            width: 100%;
            border-collapse: collapse;
            margin-top: 20px;
            margin-bottom: 20px;
        }
        table, th, td {
            border: 1px solid #ddd;
        }
        th, td {
            padding: 12px;
            text-align: left;
        }
        th {
            background-color: #f2f2f2;
            color: #333;
        }
        tr:nth-child(even) {
            background-color: #f9f9f9;
        }
    </style>
</head>
<body>

    <div class="container">
        <h1>Algorithms: Logic and Code (Python)</h1>

        <p>Algorithms are the backbone of computer science, providing step-by-step procedures to solve specific problems. Understanding common algorithms and their underlying logic is crucial for writing efficient, scalable, and robust code. This guide explores a selection of important algorithms across various categories, explaining their core ideas and providing Python implementations.</p>

        <div class="concept-section">
            <div class="collapsible-header">
                <h2>1. Sorting Algorithms</h2>
                <button class="toggle-button" data-target="sorting-algorithms-content">Expand</button>
            </div>
            <div id="sorting-algorithms-content" class="collapsible-content">
                <h3>1.1. Bubble Sort</h3>
                <p><strong>Logic:</strong> Bubble Sort repeatedly steps through the list, compares adjacent elements, and swaps them if they are in the wrong order. The pass through the list is repeated until no swaps are needed, which indicates that the list is sorted. It gets its name because smaller elements "bubble" to the top (beginning) of the list.</p>
                <p><strong>Time Complexity:</strong>
                    <ul>
                        <li>Worst-case: $O(n^2)$</li>
                        <li>Average-case: $O(n^2)$</li>
                        <li>Best-case: $O(n)$ (if already sorted)</li>
                    </ul>
                </p>
                <p><strong>Space Complexity:</strong> $O(1)$</p>
                <pre><code class="language-python">
def bubble_sort(arr):
    n = len(arr)
    # Traverse through all array elements
    for i in range(n):
        # Last i elements are already in place, so we don't need to check them
        # Optimized: if no two elements were swapped by inner loop, then break
        swapped = False
        for j in range(0, n - i - 1):
            # Traverse the array from 0 to n-i-1
            # Swap if the element found is greater than the next element
            if arr[j] > arr[j + 1]:
                arr[j], arr[j + 1] = arr[j + 1], arr[j]
                swapped = True
        
        # If no two elements were swapped by inner loop, then break
        if not swapped:
            break
    return arr

# Example Usage:
my_list = [64, 34, 25, 12, 22, 11, 90]
print(f"Original list (Bubble Sort): {my_list}")
bubble_sort(my_list)
print(f"Sorted list (Bubble Sort): {my_list}")

my_list_sorted = [10, 20, 30, 40, 50]
print(f"Original list (Bubble Sort, already sorted): {my_list_sorted}")
bubble_sort(my_list_sorted)
print(f"Sorted list (Bubble Sort, already sorted): {my_list_sorted}")
                </code></pre>

                <h3>1.2. Merge Sort</h3>
                <p><strong>Logic:</strong> Merge Sort is a divide-and-conquer algorithm. It works by recursively dividing an unsorted list into two halves until each sublist contains only one element (which is inherently sorted). Then, it repeatedly merges these sublists to produce new sorted sublists until there is only one sorted list remaining.</p>
                <p><strong>Time Complexity:</strong>
                    <ul>
                        <li>Worst-case: $O(n \log n)$</li>
                        <li>Average-case: $O(n \log n)$</li>
                        <li>Best-case: $O(n \log n)$</li>
                    </ul>
                </p>
                <p><strong>Space Complexity:</strong> $O(n)$ (due to temporary arrays used in merging)</p>
                <pre><code class="language-python">
def merge_sort(arr):
    if len(arr) &lt;= 1:
        return arr # Base case: a list with 0 or 1 element is sorted

    mid = len(arr) // 2
    left_half = arr[:mid]
    right_half = arr[mid:]

    # Recursively sort both halves
    left_half = merge_sort(left_half)
    right_half = merge_sort(right_half)

    # Merge the sorted halves
    return merge(left_half, right_half)

def merge(left, right):
    merged_list = []
    left_idx, right_idx = 0, 0

    # Compare elements from left and right halves and append the smaller one
    while left_idx &lt; len(left) and right_idx &lt; len(right):
        if left[left_idx] &lt;= right[right_idx]:
            merged_list.append(left[left_idx])
            left_idx += 1
        else:
            merged_list.append(right[right_idx])
            right_idx += 1

    # Append any remaining elements from left or right (one of them will be empty)
    merged_list.extend(left[left_idx:])
    merged_list.extend(right[right_idx:])
    return merged_list

# Example Usage:
my_list = [38, 27, 43, 3, 9, 82, 10]
print(f"Original list (Merge Sort): {my_list}")
sorted_list = merge_sort(my_list)
print(f"Sorted list (Merge Sort): {sorted_list}")
                </code></pre>

                <h3>1.3. Quick Sort</h3>
                <p><strong>Logic:</strong> Quick Sort is also a divide-and-conquer algorithm. It picks an element as a pivot and partitions the array around the picked pivot. All elements smaller than the pivot come before it, and all greater elements come after it. The process is then recursively applied to the sub-arrays of smaller and greater elements.</p>
                <p><strong>Time Complexity:</strong>
                    <ul>
                        <li>Worst-case: $O(n^2)$ (occurs with bad pivot choices, e.g., already sorted array)</li>
                        <li>Average-case: $O(n \log n)$</li>
                        <li>Best-case: $O(n \log n)$</li>
                    </ul>
                </p>
                <p><strong>Space Complexity:</strong> $O(\log n)$ (for recursion stack in average case), $O(n)$ (in worst case)</p>
                <pre><code class="language-python">
def quick_sort(arr):
    if len(arr) &lt;= 1:
        return arr # Base case: a list with 0 or 1 element is sorted

    pivot = arr[len(arr) // 2] # Choose a pivot (middle element for simplicity)
    left = [x for x in arr if x &lt; pivot]
    middle = [x for x in arr if x == pivot]
    right = [x for x in arr if x > pivot]

    # Recursively sort the left and right partitions, then combine
    return quick_sort(left) + middle + quick_sort(right)

# Example Usage:
my_list = [10, 7, 8, 9, 1, 5]
print(f"Original list (Quick Sort): {my_list}")
sorted_list = quick_sort(my_list)
print(f"Sorted list (Quick Sort): {sorted_list}")
                </code></pre>
            </div>
        </div>

        <div class="concept-section">
            <div class="collapsible-header">
                <h2>2. Searching Algorithms</h2>
                <button class="toggle-button" data-target="searching-algorithms-content">Expand</button>
            </div>
            <div id="searching-algorithms-content" class="collapsible-content">
                <h3>2.1. Linear Search</h3>
                <p><strong>Logic:</strong> Linear Search (or Sequential Search) is the simplest searching algorithm. It sequentially checks each element of the list until a match is found or the entire list has been searched.</p>
                <p><strong>Time Complexity:</strong>
                    <ul>
                        <li>Worst-case: $O(n)$</li>
                        <li>Average-case: $O(n)$</li>
                        <li>Best-case: $O(1)$ (if element is at the beginning)</li>
                    </ul>
                </p>
                <p><strong>Space Complexity:</strong> $O(1)$</p>
                <pre><code class="language-python">
def linear_search(arr, target):
    for i in range(len(arr)):
        if arr[i] == target:
            return i # Return the index if target is found
    return -1 # Return -1 if target is not found

# Example Usage:
my_list = [10, 20, 80, 30, 60, 50, 110, 100, 130, 170]
target1 = 30
target2 = 99

print(f"List for search: {my_list}")
print(f"Linear Search: {target1} found at index {linear_search(my_list, target1)}")
print(f"Linear Search: {target2} found at index {linear_search(my_list, target2)}")
                </code></pre>

                <h3>2.2. Binary Search</h3>
                <p><strong>Logic:</strong> Binary Search is an efficient algorithm for finding an item from a sorted list of items. It works by repeatedly dividing the search interval in half. If the value of the search key is less than the item in the middle of the interval, narrow the interval to the lower half. Otherwise, narrow it to the upper half. Repeatedly check until the value is found or the interval is empty.</p>
                <p><strong>Pre-requisite:</strong> The input list **must be sorted**.</p>
                <p><strong>Time Complexity:</strong>
                    <ul>
                        <li>Worst-case: $O(\log n)$</li>
                        <li>Average-case: $O(\log n)$</li>
                        <li>Best-case: $O(1)$</li>
                    </ul>
                </p>
                <p><strong>Space Complexity:</strong> $O(1)$ (iterative), $O(\log n)$ (recursive for call stack)</p>
                <pre><code class="language-python">
def binary_search(arr, target):
    low = 0
    high = len(arr) - 1

    while low &lt;= high:
        mid = (low + high) // 2 # Calculate middle index
        
        # Check if target is present at mid
        if arr[mid] == target:
            return mid
        
        # If target is greater, ignore left half
        elif arr[mid] &lt; target:
            low = mid + 1
        
        # If target is smaller, ignore right half
        else:
            high = mid - 1
            
    return -1 # Target not found

# Example Usage:
my_sorted_list = [10, 20, 30, 40, 50, 60, 70, 80, 90, 100]
target1 = 70
target2 = 35

print(f"Sorted list for search: {my_sorted_list}")
print(f"Binary Search: {target1} found at index {binary_search(my_sorted_list, target1)}")
print(f"Binary Search: {target2} found at index {binary_search(my_sorted_list, target2)}")
                </code></pre>
            </div>
        </div>

        <div class="concept-section">
            <div class="collapsible-header">
                <h2>3. Data Structure Algorithms (Operations)</h2>
                <button class="toggle-button" data-target="ds-algorithms-content">Expand</button>
            </div>
            <div id="ds-algorithms-content" class="collapsible-content">
                <h3>3.1. Stack (LIFO)</h3>
                <p><strong>Logic:</strong> A Stack is a linear data structure that follows the LIFO (Last In, First Out) principle. Operations include:</p>
                <ul>
                    <li><code>push</code>: Adds an element to the top of the stack.</li>
                    <li><code>pop</code>: Removes and returns the top element from the stack.</li>
                    <li><code>peek</code>: Returns the top element without removing it.</li>
                    <li><code>is_empty</code>: Checks if the stack is empty.</li>
                </ul>
                <p><strong>Time Complexity (all operations):</strong> $O(1)$</p>
                <p><strong>Space Complexity:</strong> $O(n)$</p>
                <pre><code class="language-python">
class Stack:
    def __init__(self):
        self.items = []

    def is_empty(self):
        return len(self.items) == 0

    def push(self, item):
        self.items.append(item)
        print(f"Pushed: {item}. Stack: {self.items}")

    def pop(self):
        if self.is_empty():
            print("Stack is empty. Cannot pop.")
            return None
        popped_item = self.items.pop()
        print(f"Popped: {popped_item}. Stack: {self.items}")
        return popped_item

    def peek(self):
        if self.is_empty():
            print("Stack is empty. Cannot peek.")
            return None
        return self.items[-1]

    def size(self):
        return len(self.items)

# Example Usage:
print("--- Stack Demo ---")
stack = Stack()
stack.push(10)
stack.push(20)
print(f"Peek: {stack.peek()}")
stack.pop()
stack.pop()
stack.pop() # Try to pop from empty stack
print(f"Is stack empty? {stack.is_empty()}")
                </code></pre>

                <h3>3.2. Queue (FIFO)</h3>
                <p><strong>Logic:</strong> A Queue is a linear data structure that follows the FIFO (First In, First Out) principle. Operations include:</p>
                <ul>
                    <li><code>enqueue</code>: Adds an element to the rear of the queue.</li>
                    <li><code>dequeue</code>: Removes and returns the front element from the queue.</li>
                    <li><code>front</code>: Returns the front element without removing it.</li>
                    <li><code>is_empty</code>: Checks if the queue is empty.</li>
                </ul>
                <p><strong>Time Complexity (all operations):</strong> $O(1)$ (using `collections.deque` for efficient dequeue from front)</p>
                <p><strong>Space Complexity:</strong> $O(n)$</p>
                <pre><code class="language-python">
from collections import deque

class Queue:
    def __init__(self):
        self.items = deque() # Use deque for efficient O(1) appends and pops from both ends

    def is_empty(self):
        return len(self.items) == 0

    def enqueue(self, item):
        self.items.append(item)
        print(f"Enqueued: {item}. Queue: {list(self.items)}")

    def dequeue(self):
        if self.is_empty():
            print("Queue is empty. Cannot dequeue.")
            return None
        dequeued_item = self.items.popleft() # O(1) operation
        print(f"Dequeued: {dequeued_item}. Queue: {list(self.items)}")
        return dequeued_item

    def front(self):
        if self.is_empty():
            print("Queue is empty. Cannot peek.")
            return None
        return self.items[0]

    def size(self):
        return len(self.items)

# Example Usage:
print("\n--- Queue Demo ---")
queue = Queue()
queue.enqueue("Task A")
queue.enqueue("Task B")
print(f"Front of queue: {queue.front()}")
queue.dequeue()
queue.enqueue("Task C")
queue.dequeue()
queue.dequeue()
queue.dequeue() # Try to dequeue from empty queue
print(f"Is queue empty? {queue.is_empty()}")
                </code></pre>

                <h3>3.3. Linked List (Singly Linked List Operations)</h3>
                <p><strong>Logic:</strong> A Linked List is a linear data structure where elements are not stored at contiguous memory locations. Instead, each element (node) stores its own data and a pointer (or reference) to the next node in the sequence. This allows for efficient insertions and deletions at arbitrary positions compared to arrays.</p>
                <p><strong>Time Complexity:</strong>
                    <ul>
                        <li>Insertion/Deletion at head: $O(1)$</li>
                        <li>Insertion/Deletion at tail (without tail pointer): $O(n)$</li>
                        <li>Insertion/Deletion at specific position: $O(n)$</li>
                        <li>Search: $O(n)$</li>
                    </ul>
                </p>
                <p><strong>Space Complexity:</strong> $O(n)$</p>
                <pre><code class="language-python">
class Node:
    def __init__(self, data):
        self.data = data
        self.next = None # Pointer to the next node

class LinkedList:
    def __init__(self):
        self.head = None # Head of the list

    def is_empty(self):
        return self.head is None

    def append(self, data):
        """Adds a new node to the end of the list."""
        new_node = Node(data)
        if self.is_empty():
            self.head = new_node
            return
        last_node = self.head
        while last_node.next:
            last_node = last_node.next
        last_node.next = new_node
        print(f"Appended: {data}")

    def prepend(self, data):
        """Adds a new node to the beginning of the list."""
        new_node = Node(data)
        new_node.next = self.head
        self.head = new_node
        print(f"Prepended: {data}")

    def delete(self, key):
        """Deletes the first node with the given key."""
        current = self.head
        if current and current.data == key:
            self.head = current.next
            current = None
            print(f"Deleted head: {key}")
            return

        prev = None
        while current and current.data != key:
            prev = current
            current = current.next

        if current is None: # Key not found
            print(f"Key {key} not found for deletion.")
            return

        prev.next = current.next
        current = None
        print(f"Deleted: {key}")

    def search(self, key):
        """Searches for a node with the given key."""
        current = self.head
        while current:
            if current.data == key:
                return True
            current = current.next
        return False

    def display(self):
        """Prints the linked list."""
        elements = []
        current = self.head
        while current:
            elements.append(str(current.data))
            current = current.next
        print("Linked List: " + " -> ".join(elements))

# Example Usage:
print("\n--- Linked List Demo ---")
ll = LinkedList()
ll.append(1)
ll.append(2)
ll.prepend(0)
ll.display() # Output: Linked List: 0 -> 1 -> 2

print(f"Search for 1: {ll.search(1)}") # True
print(f"Search for 5: {ll.search(5)}") # False

ll.delete(1)
ll.display() # Output: Linked List: 0 -> 2

ll.delete(0)
ll.display() # Output: Linked List: 2

ll.delete(5) # Key not found
ll.delete(2)
ll.display() # Output: Linked List:
print(f"Is list empty? {ll.is_empty()}") # True
                </code></pre>

                <h3>3.4. Tree Traversal (Binary Tree)</h3>
                <p><strong>Logic:</strong> Tree traversal refers to the process of visiting each node in a tree data structure exactly once. For binary trees, common traversal methods are:</p>
                <ul>
                    <li><strong>Inorder Traversal (Left-Root-Right):</strong> Visits the left subtree, then the root node, then the right subtree. For a Binary Search Tree (BST), this yields elements in sorted order.</li>
                    <li><strong>Preorder Traversal (Root-Left-Right):</strong> Visits the root node, then the left subtree, then the right subtree. Useful for creating a copy of the tree.</li>
                    <li><strong>Postorder Traversal (Left-Right-Root):</strong> Visits the left subtree, then the right subtree, then the root node. Useful for deleting a tree or evaluating expressions.</li>
                </ul>
                <p><strong>Time Complexity (all traversals):</strong> $O(n)$ (where n is the number of nodes)</p>
                <p><strong>Space Complexity:</strong> $O(h)$ (where h is the height of the tree, for recursion stack)</p>
                <pre><code class="language-python">
class TreeNode:
    def __init__(self, data):
        self.data = data
        self.left = None
        self.right = None

def inorder_traversal(node):
    """Left -&gt; Root -&gt; Right"""
    if node:
        inorder_traversal(node.left)
        print(node.data, end=" ")
        inorder_traversal(node.right)

def preorder_traversal(node):
    """Root -&gt; Left -&gt; Right"""
    if node:
        print(node.data, end=" ")
        preorder_traversal(node.left)
        preorder_traversal(node.right)

def postorder_traversal(node):
    """Left -&gt; Right -&gt; Root"""
    if node:
        postorder_traversal(node.left)
        postorder_traversal(node.right)
        print(node.data, end=" ")

# Example Tree Structure:
#        1
#       / \
#      2   3
#     / \
#    4   5

root = TreeNode(1)
root.left = TreeNode(2)
root.right = TreeNode(3)
root.left.left = TreeNode(4)
root.left.right = TreeNode(5)

print("\n--- Tree Traversal Demo ---")
print("Inorder Traversal:")
inorder_traversal(root) # Expected: 4 2 5 1 3
print("\nPreorder Traversal:")
preorder_traversal(root) # Expected: 1 2 4 5 3
print("\nPostorder Traversal:")
postorder_traversal(root) # Expected: 4 5 2 3 1
print("\n")
                </code></pre>
            </div>
        </div>

        <div class="concept-section">
            <div class="collapsible-header">
                <h2>4. Graph Algorithms</h2>
                <button class="toggle-button" data-target="graph-algorithms-content">Expand</button>
            </div>
            <div id="graph-algorithms-content" class="collapsible-content">
                <p>Graphs are non-linear data structures consisting of nodes (vertices) and edges. Graph algorithms are used to solve problems like finding paths, shortest paths, or connectivity.</p>
                <pre><code class="language-python">
# Basic Graph Representation (Adjacency List)
graph = {
    'A': ['B', 'C'],
    'B': ['A', 'D', 'E'],
    'C': ['A', 'F'],
    'D': ['B'],
    'E': ['B', 'F'],
    'F': ['C', 'E']
}
                </code></pre>

                <h3>4.1. Breadth-First Search (BFS)</h3>
                <p><strong>Logic:</strong> BFS is a graph traversal algorithm that explores all the neighbor nodes at the present depth level before moving on to nodes at the next depth level. It uses a queue to keep track of nodes to visit.</p>
                <p><strong>Time Complexity:</strong> $O(V + E)$ (where V is vertices, E is edges)</p>
                <p><strong>Space Complexity:</strong> $O(V)$</p>
                <pre><code class="language-python">
from collections import deque

def bfs(graph, start_node):
    visited = set()
    queue = deque([start_node])
    visited.add(start_node)

    traversal_order = []

    while queue:
        current_node = queue.popleft()
        traversal_order.append(current_node)

        for neighbor in graph[current_node]:
            if neighbor not in visited:
                visited.add(neighbor)
                queue.append(neighbor)
    return traversal_order

# Example Usage:
graph_bfs = {
    'A': ['B', 'C'],
    'B': ['A', 'D', 'E'],
    'C': ['A', 'F'],
    'D': ['B'],
    'E': ['B', 'F'],
    'F': ['C', 'E']
}
print("--- BFS Demo ---")
print(f"BFS traversal from 'A': {bfs(graph_bfs, 'A')}") # Expected: ['A', 'B', 'C', 'D', 'E', 'F']
                </code></pre>

                <h3>4.2. Depth-First Search (DFS)</h3>
                <p><strong>Logic:</strong> DFS is a graph traversal algorithm that explores as far as possible along each branch before backtracking. It uses a stack (implicitly, via recursion, or explicitly) to keep track of nodes to visit.</p>
                <p><strong>Time Complexity:</strong> $O(V + E)$</p>
                <p><strong>Space Complexity:</strong> $O(V)$ (for recursion stack)</p>
                <pre><code class="language-python">
def dfs(graph, start_node):
    visited = set()
    traversal_order = []

    def dfs_recursive(node):
        visited.add(node)
        traversal_order.append(node)
        for neighbor in graph[node]:
            if neighbor not in visited:
                dfs_recursive(neighbor)

    dfs_recursive(start_node)
    return traversal_order

# Example Usage:
graph_dfs = {
    'A': ['B', 'C'],
    'B': ['A', 'D', 'E'],
    'C': ['A', 'F'],
    'D': ['B'],
    'E': ['B', 'F'],
    'F': ['C', 'E']
}
print("\n--- DFS Demo ---")
print(f"DFS traversal from 'A': {dfs(graph_dfs, 'A')}") # Expected (one possible order): ['A', 'B', 'D', 'E', 'F', 'C']
                </code></pre>

                <h3>4.3. Dijkstra's Algorithm (Shortest Path)</h3>
                <p><strong>Logic:</strong> Dijkstra's algorithm finds the shortest paths from a single source node to all other nodes in a graph with non-negative edge weights. It uses a priority queue to always explore the unvisited node with the smallest known distance from the source.</p>
                <p><strong>Time Complexity:</strong> $O((V + E) \log V)$ (using a min-priority queue/heap)</p>
                <p><strong>Space Complexity:</strong> $O(V + E)$</p>
                <pre><code class="language-python">
import heapq # Python's min-heap implementation

def dijkstra(graph, start_node):
    # distances: stores the shortest distance from start_node to each node
    distances = {node: float('infinity') for node in graph}
    distances[start_node] = 0

    # priority_queue: stores (distance, node) tuples, ordered by distance
    priority_queue = [(0, start_node)] # (distance, node)

    while priority_queue:
        current_distance, current_node = heapq.heappop(priority_queue)

        # If we've already found a shorter path to this node, skip
        if current_distance > distances[current_node]:
            continue

        for neighbor, weight in graph[current_node].items():
            distance = current_distance + weight
            # If a shorter path to neighbor is found
            if distance &lt; distances[neighbor]:
                distances[neighbor] = distance
                heapq.heappush(priority_queue, (distance, neighbor))
    
    return distances

# Example Usage (Weighted Graph):
graph_dijkstra = {
    'A': {'B': 1, 'C': 4},
    'B': {'A': 1, 'D': 2, 'E': 5},
    'C': {'A': 4, 'F': 1},
    'D': {'B': 2},
    'E': {'B': 5, 'F': 1},
    'F': {'C': 1, 'E': 1}
}
print("\n--- Dijkstra's Algorithm Demo ---")
shortest_paths = dijkstra(graph_dijkstra, 'A')
print(f"Shortest paths from 'A': {shortest_paths}")
# Expected: {'A': 0, 'B': 1, 'C': 4, 'D': 3, 'E': 6, 'F': 5}
                </code></pre>
            </div>
        </div>

        <div class="concept-section">
            <div class="collapsible-header">
                <h2>5. Dynamic Programming (DP)</h2>
                <button class="toggle-button" data-target="dp-algorithms-content">Expand</button>
            </div>
            <div id="dp-algorithms-content" class="collapsible-content">
                <p>Dynamic Programming is an algorithmic technique for solving a complex problem by breaking it down into simpler subproblems. It's applicable to problems that have overlapping subproblems and optimal substructure.</p>
                <ul>
                    <li><strong>Overlapping Subproblems:</strong> The same subproblems are solved multiple times. DP solves each subproblem only once and stores the results.</li>
                    <li><strong>Optimal Substructure:</strong> An optimal solution to the problem can be constructed from optimal solutions of its subproblems.</li>
                </ul>
                <p>Two main approaches:</p>
                <ul>
                    <li><strong>Memoization (Top-Down):</strong> Recursive approach that stores the results of expensive function calls and returns the cached result when the same inputs occur again.</li>
                    <li><strong>Tabulation (Bottom-Up):</strong> Iterative approach that solves subproblems first and then builds up solutions to larger problems.</li>
                </ul>

                <h3>5.1. Fibonacci Sequence (Memoization vs. Tabulation)</h3>
                <p><strong>Problem:</strong> Calculate the n-th Fibonacci number ($F_n = F_{n-1} + F_{n-2}$, with $F_0=0, F_1=1$).</p>
                <pre><code class="language-python">
# --- Recursive (Naive) Fibonacci ---
# Time Complexity: O(2^n) - highly inefficient due to redundant calculations
def fib_recursive(n):
    if n &lt;= 1:
        return n
    return fib_recursive(n - 1) + fib_recursive(n - 2)

# --- Fibonacci with Memoization (Top-Down DP) ---
# Logic: Store results of subproblems in a dictionary (memo) to avoid re-calculation.
# Time Complexity: O(n)
# Space Complexity: O(n) (for memoization table and recursion stack)
memo = {}
def fib_memoization(n):
    if n &lt;= 1:
        return n
    if n in memo:
        return memo[n]
    
    memo[n] = fib_memoization(n - 1) + fib_memoization(n - 2)
    return memo[n]

# --- Fibonacci with Tabulation (Bottom-Up DP) ---
# Logic: Build up the solution iteratively from base cases.
# Time Complexity: O(n)
# Space Complexity: O(n) (for DP table)
def fib_tabulation(n):
    if n &lt;= 1:
        return n
    
    dp = [0] * (n + 1)
    dp[0] = 0
    dp[1] = 1
    
    for i in range(2, n + 1):
        dp[i] = dp[i - 1] + dp[i - 2]
    
    return dp[n]

# --- Fibonacci with Space Optimization (Bottom-Up DP) ---
# Logic: Notice that we only need the previous two numbers.
# Time Complexity: O(n)
# Space Complexity: O(1)
def fib_space_optimized(n):
    if n &lt;= 1:
        return n
    
    a, b = 0, 1
    for _ in range(2, n + 1):
        a, b = b, a + b
    return b

# Example Usage:
print("--- Fibonacci Sequence Demo (DP) ---")
n = 10
print(f"Fibonacci({n}) (Recursive): {fib_recursive(n)}")
print(f"Fibonacci({n}) (Memoization): {fib_memoization(n)}")
print(f"Fibonacci({n}) (Tabulation): {fib_tabulation(n)}")
print(f"Fibonacci({n}) (Space Optimized): {fib_space_optimized(n)}")

n_large = 35 # Recursive would be very slow for this
print(f"Fibonacci({n_large}) (Memoization): {fib_memoization(n_large)}")
print(f"Fibonacci({n_large}) (Space Optimized): {fib_space_optimized(n_large)}")
                </code></pre>

                <h3>5.2. 0/1 Knapsack Problem (Conceptual)</h3>
                <p><strong>Problem:</strong> Given a set of items, each with a weight and a value, determine the number of each item to include in a collection so that the total weight is less than or equal to a given limit and the total value is as large as possible. Each item can either be included (1) or not (0).</p>
                <p><strong>Logic:</strong> This problem exhibits optimal substructure and overlapping subproblems. A common DP approach is to build a table `dp[i][w]` representing the maximum value that can be obtained from the first `i` items with a maximum weight capacity of `w`.</p>
                <ul>
                    <li>If the `i`-th item's weight is greater than `w`, it cannot be included: `dp[i][w] = dp[i-1][w]`</li>
                    <li>If the `i`-th item's weight is less than or equal to `w`, it can either be included or excluded:
                        `dp[i][w] = max(dp[i-1][w], value[i-1] + dp[i-1][w - weight[i-1]])`
                    </li>
                </ul>
                <p><strong>Time Complexity:</strong> $O(nW)$ (where n is number of items, W is max weight capacity)</p>
                <p><strong>Space Complexity:</strong> $O(nW)$ (can be optimized to $O(W)$)</p>
                <pre><code class="language-python">
def knapsack_01(weights, values, capacity):
    n = len(weights)
    
    # dp[i][w] will store the maximum value that can be obtained
    # using items from 0 to i-1 with weight capacity w
    dp = [[0 for _ in range(capacity + 1)] for _ in range(n + 1)]

    for i in range(1, n + 1):
        for w in range(1, capacity + 1):
            current_weight = weights[i-1]
            current_value = values[i-1]

            # If current item's weight is more than current capacity 'w',
            # then this item cannot be included
            if current_weight > w:
                dp[i][w] = dp[i-1][w]
            else:
                # Max of (not including current item, including current item)
                dp[i][w] = max(dp[i-1][w], current_value + dp[i-1][w - current_weight])
    
    return dp[n][capacity]

# Example Usage:
weights = [1, 2, 3, 4]
values = [10, 20, 30, 40]
capacity = 5

print("\n--- 0/1 Knapsack Problem Demo (DP) ---")
max_value = knapsack_01(weights, values, capacity)
print(f"Items: Weights={weights}, Values={values}, Capacity={capacity}")
print(f"Maximum value in knapsack: {max_value}") # Expected: 60 (items with weights 2 and 3, values 20 and 30)

weights2 = [4, 5, 1]
values2 = [10, 20, 5]
capacity2 = 6
max_value2 = knapsack_01(weights2, values2, capacity2)
print(f"Items: Weights={weights2}, Values={values2}, Capacity={capacity2}")
print(f"Maximum value in knapsack: {max_value2}") # Expected: 25 (item with weight 5, value 20 + item with weight 1, value 5)
                </code></pre>
            </div>
        </div>

        <div class="concept-section">
            <div class="collapsible-header">
                <h2>6. Greedy Algorithms</h2>
                <button class="toggle-button" data-target="greedy-algorithms-content">Expand</button>
            </div>
            <div id="greedy-algorithms-content" class="collapsible-content">
                <p><strong>Logic:</strong> A greedy algorithm makes the locally optimal choice at each stage with the hope of finding a global optimum. It doesn't always yield the globally optimal solution, but for some problems, it does.</p>

                <h3>6.1. Activity Selection Problem</h3>
                <p><strong>Problem:</strong> Given a set of activities, each with a start and finish time, select the maximum number of non-overlapping activities that can be performed by a single person.</p>
                <p><strong>Logic:</strong> The greedy choice is to always select the activity that finishes earliest among the remaining compatible activities. This leaves the maximum time available for other activities.</p>
                <p><strong>Time Complexity:</strong> $O(n \log n)$ (due to sorting)</p>
                <p><strong>Space Complexity:</strong> $O(1)$ or $O(n)$ depending on storage of results</p>
                <pre><code class="language-python">
def activity_selection(activities):
    """
    Selects the maximum number of non-overlapping activities.
    Activities should be a list of tuples: (start_time, finish_time).
    """
    if not activities:
        return []

    # 1. Sort activities by their finish times
    # This is the crucial greedy step
    activities.sort(key=lambda x: x[1])

    selected_activities = []
    
    # Select the first activity (it has the earliest finish time)
    selected_activities.append(activities[0])
    last_finish_time = activities[0][1]

    # Iterate through the remaining activities
    for i in range(1, len(activities)):
        start_time, finish_time = activities[i]
        
        # If the current activity's start time is after or equal to the
        # last selected activity's finish time, select it.
        if start_time >= last_finish_time:
            selected_activities.append(activities[i])
            last_finish_time = finish_time
            
    return selected_activities

# Example Usage:
# Activities: (start_time, finish_time)
activities = [(1, 4), (3, 5), (0, 6), (5, 7), (3, 8), (5, 9), (6, 10), (8, 11), (8, 12), (2, 13), (12, 14)]

print("--- Activity Selection Problem Demo (Greedy) ---")
print(f"Original activities: {activities}")
selected = activity_selection(activities)
print(f"Selected non-overlapping activities: {selected}")
# Expected: [(1, 4), (5, 7), (8, 11), (12, 14)] (or similar based on tie-breaking in sort)
                </code></pre>
            </div>
        </div>

        <div class="concept-section">
            <div class="collapsible-header">
                <h2>7. String Algorithms</h2>
                <button class="toggle-button" data-target="string-algorithms-content">Expand</button>
            </div>
            <div id="string-algorithms-content" class="collapsible-content">
                <h3>7.1. Palindrome Check</h3>
                <p><strong>Logic:</strong> A palindrome is a word, phrase, number, or other sequence of characters that reads the same forward and backward. The algorithm checks if a string is equal to its reverse.</p>
                <p><strong>Time Complexity:</strong> $O(n)$</p>
                <p><strong>Space Complexity:</strong> $O(n)$ (for creating reversed string/list), $O(1)$ (two-pointer approach)</p>
                <pre><code class="language-python">
def is_palindrome(s):
    # Option 1: Using slicing (Pythonic, but creates a new string)
    # return s == s[::-1]

    # Option 2: Two-pointer approach (O(1) space, more generalizable)
    left = 0
    right = len(s) - 1
    while left &lt; right:
        if s[left] != s[right]:
            return False
        left += 1
        right -= 1
    return True

# Example Usage:
print("--- Palindrome Check Demo ---")
print(f"'madam' is palindrome: {is_palindrome('madam')}")
print(f"'racecar' is palindrome: {is_palindrome('racecar')}")
print(f"'hello' is palindrome: {is_palindrome('hello')}")
print(f"'' is palindrome: {is_palindrome('')}")
print(f"'a' is palindrome: {is_palindrome('a')}")
                </code></pre>

                <h3>7.2. Anagram Check</h3>
                <p><strong>Logic:</strong> Two strings are anagrams if they contain the same characters with the same frequencies, but in a different order. The algorithm usually involves sorting both strings and comparing them, or counting character frequencies.</p>
                <p><strong>Time Complexity:</strong> $O(n \log n)$ (due to sorting) or $O(n)$ (using hash maps/frequency arrays)</p>
                <p><strong>Space Complexity:</strong> $O(n)$ (for sorted strings or hash map)</p>
                <pre><code class="language-python">
def are_anagrams(s1, s2):
    # Option 1: Sort and compare (simple, but O(N log N))
    # return sorted(s1) == sorted(s2)

    # Option 2: Using frequency counts (O(N) time, O(alphabet_size) space)
    if len(s1) != len(s2):
        return False

    char_counts = {}
    for char in s1:
        char_counts[char] = char_counts.get(char, 0) + 1
    
    for char in s2:
        char_counts[char] = char_counts.get(char, 0) - 1
        if char_counts[char] &lt; 0: # More of a char in s2 than s1
            return False
    
    # All counts should be zero if they are anagrams
    for count in char_counts.values():
        if count != 0:
            return False
            
    return True

# Example Usage:
print("\n--- Anagram Check Demo ---")
print(f"'listen' and 'silent' are anagrams: {are_anagrams('listen', 'silent')}")
print(f"'hello' and 'world' are anagrams: {are_anagrams('hello', 'world')}")
print(f"'anagram' and 'nagaram' are anagrams: {are_anagrams('anagram', 'nagaram')}")
print(f"'rat' and 'car' are anagrams: {are_anagrams('rat', 'car')}")
                </code></pre>
            </div>
        </div>

        <div class="concept-section">
            <div class="collapsible-header">
                <h2>8. Recursion</h2>
                <button class="toggle-button" data-target="recursion-content">Expand</button>
            </div>
            <div id="recursion-content" class="collapsible-content">
                <p><strong>Logic:</strong> Recursion is a programming technique where a function calls itself directly or indirectly to solve a problem. A recursive function must have:</p>
                <ul>
                    <li><strong>Base Case(s):</strong> A condition that stops the recursion, preventing infinite loops.</li>
                    <li><strong>Recursive Step:</strong> The part where the function calls itself with a modified input, moving closer to the base case.</li>
                </ul>
                <p>Recursion often makes code more elegant and readable for problems that have a naturally recursive structure (e.g., tree traversals, fractals, divide-and-conquer algorithms).</p>

                <h3>8.1. Factorial Calculation</h3>
                <p><strong>Problem:</strong> Calculate the factorial of a non-negative integer $n$ ($n! = n \times (n-1) \times \dots \times 1$).</p>
                <p><strong>Base Case:</strong> $0! = 1$ and $1! = 1$.</p>
                <p><strong>Recursive Step:</strong> $n! = n \times (n-1)!$</p>
                <p><strong>Time Complexity:</strong> $O(n)$</p>
                <p><strong>Space Complexity:</strong> $O(n)$ (for recursion stack)</p>
                <pre><code class="language-python">
def factorial_recursive(n):
    if n &lt; 0:
        raise ValueError("Factorial is not defined for negative numbers.")
    if n == 0 or n == 1: # Base case
        return 1
    else: # Recursive step
        return n * factorial_recursive(n - 1)

# Example Usage:
print("--- Factorial Calculation Demo (Recursion) ---")
print(f"Factorial of 5: {factorial_recursive(5)}")   # Expected: 120
print(f"Factorial of 0: {factorial_recursive(0)}")   # Expected: 1
print(f"Factorial of 1: {factorial_recursive(1)}")   # Expected: 1
# print(factorial_recursive(-3)) # This will raise ValueError
                </code></pre>

                <h3>8.2. Tower of Hanoi (Conceptual)</h3>
                <p><strong>Problem:</strong> Move `n` disks from a source peg to a destination peg using an auxiliary peg, following specific rules (only one disk moved at a time, larger disk cannot be placed on smaller disk).</p>
                <p><strong>Logic:</strong> This is a classic recursive problem that perfectly illustrates the power of recursion.
                    <ol>
                        <li>Move `n-1` disks from Source to Auxiliary peg.</li>
                        <li>Move the largest disk (n-th disk) from Source to Destination peg.</li>
                        <li>Move `n-1` disks from Auxiliary to Destination peg.</li>
                    </ol>
                </p>
                <p><strong>Base Case:</strong> If there's only 1 disk, move it directly from source to destination.</p>
                <p><strong>Time Complexity:</strong> $O(2^n)$</p>
                <p><strong>Space Complexity:</strong> $O(n)$ (for recursion stack)</p>
                <pre><code class="language-python">
def tower_of_hanoi(n, source, auxiliary, destination):
    if n == 1: # Base case: only one disk to move
        print(f"Move disk 1 from {source} to {destination}")
        return
    
    # Step 1: Move n-1 disks from Source to Auxiliary
    tower_of_hanoi(n - 1, source, destination, auxiliary)
    
    # Step 2: Move the nth disk from Source to Destination
    print(f"Move disk {n} from {source} to {destination}")
    
    # Step 3: Move n-1 disks from Auxiliary to Destination
    tower_of_hanoi(n - 1, auxiliary, source, destination)

# Example Usage:
print("\n--- Tower of Hanoi Demo (Recursion) ---")
n_disks = 3
print(f"Solving Tower of Hanoi for {n_disks} disks:")
tower_of_hanoi(n_disks, 'A', 'B', 'C') # A: Source, B: Auxiliary, C: Destination
                </code></pre>
            </div>
        </div>

        <div class="warning">
            <p>This guide covers a selection of fundamental and important algorithms. The world of algorithms is vast and includes many more specialized techniques (e.g., graph traversal variations, advanced sorting, string matching, computational geometry, cryptographic algorithms). Continuous learning and practice are key to mastering algorithmic thinking.</p>
        </div>

    </div>

    <script>
        document.addEventListener('DOMContentLoaded', function() {
            const toggleButtons = document.querySelectorAll('.toggle-button');

            toggleButtons.forEach(button => {
                const targetId = button.dataset.target;
                const contentDiv = document.getElementById(targetId);

                if (contentDiv) {
                    // Initialize state: all collapsed by default
                    contentDiv.style.display = 'none';
                    button.textContent = 'Expand';
                    button.classList.add('collapsed');

                    button.addEventListener('click', function() {
                        if (contentDiv.style.display === 'block') {
                            contentDiv.style.display = 'none';
                            button.textContent = 'Expand';
                            button.classList.add('collapsed');
                        } else {
                            contentDiv.style.display = 'block';
                            button.textContent = 'Collapse';
                            button.classList.remove('collapsed');
                        }
                    });
                }
            });
        });
    </script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-python.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-line-numbers.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/line-numbers/prism-line-numbers.min.js"></script>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism-tomorrow.min.css">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/line-numbers/prism-line-numbers.min.css">
    <script>Prism.plugins.lineNumbers();</script>
    <script>Prism.highlightAll();</script>
</body>
</html>
